---
title: "Integrative analysis in Seurat v5"
output:
  html_document:
    theme: united
  pdf_document: default
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---

```{r setup, include=FALSE}
all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(
  tidy = 'styler',
  fig.width = 8,
  message = FALSE,
  warning = FALSE,
  time_it = TRUE,
  error = TRUE
)
```

```{r init}
library(Seurat)
library(tidyverse)
library(ggplot2)
library(patchwork)
library(SingleCellExperiment)
library(SingleR)
library(celldex)
library(dplyr)
```

## Set up the Seurat objects
We will look at a dataset pooling 6 single cell sequencing data files from 3 patients, each with tumor and peritumor tissue collected and sequenced.

The data has already been processed through the commented out code, and can be loaded from `obj_raw_counts.rds`.

```{r process}
# file_list = list.files(pattern = "\\.csv$")
# obj_list <- lapply(file_list, function(file) {
#   counts <- read.csv(file, comment.char = "#", row.names = 1)
#   counts <- t(counts)
#   obj <- CreateSeuratObject(counts = counts, project = basename(file), min.cells = 3, min.features = 200)
#   
#   parts <- unlist(strsplit(file, "_"))
#   obj$ind <- parts[1]
#   obj$tissue <- parts[2]
#   return(obj)
# })
# obj <- merge(obj_list[[1]], obj_list[2:6])
# saveRDS(obj, file = "obj_raw_counts.rds")
```

```{r load}
# load in the dataset
obj <- readRDS(file = "obj_raw_counts.rds")

head(obj@meta.data)
```

- `ind` identifies a cell as coming from one of 3 individuals.
- `tissue` identifies a cell as coming from tumor (`Ca`) or peritumor tissue (`N`).

Examine the object:
```{r}
glimpse(obj)
```


## QC and selecting cells for further analysis

Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics by the community include

* The number of unique genes detected in each cell. 
    + Low-quality cells or empty droplets will often have very few genes
    + Cell doublets or multiplets may exhibit an aberrantly high gene count
* Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)
* The percentage of reads that map to the mitochondrial genome
    + Low-quality / dying cells often exhibit extensive mitochondrial contamination
    + We calculate mitochondrial QC metrics with the `PercentageFeatureSet()` function, which calculates the percentage of counts originating from a set of features
    + We use the set of all genes starting with `MT.` as a set of mitochondrial genes

```{r qc}
# # We need join layers from different batch for preprocessing
# obj <- JoinLayers(obj)

obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT\\.")
# Show QC metrics for the first 5 cells
head(obj@meta.data, 5)
```

```{r qc2, fig.height=7, fig.width=13}

#Visualize QC metrics as a violin plot
VlnPlot(obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1
plot2
# inspect if mt genes really have high gene counts
# grep("^MT\\.", rownames(x = obj), value = T)
# rowSums(obj[["RNA"]]$counts[c(grep("^MT\\.", rownames(x = obj), value = T), "CD3D", "TCL1A", "MS4A1"), ])

obj <- subset(obj, subset = nFeature_RNA > 200 & nFeature_RNA < 4500 & percent.mt < 15)
obj
```
In the example below, we visualize QC metrics, and use these to filter cells.

* We filter cells that have unique feature counts over 4,500 or less than 200
* We filter cells that have >15% mitochondrial counts

### Reviewing the Data
As we can see above, the `glimpse` command shows the metadata that can be used to classify the cells. Within Seurat, the metadata is used to define the "identity" of the dataset. This is critical, as the labels within the categories will be used to determine which groups of cells are being compared. One method of viewing the available labels is to use the `table` function, which lists the frequency of each label:

```{r}
table(obj$ind)
```
The table function can also be used in two dimensions:

```{r}
table(obj$ind,obj$tissue)
```
We can then run a standard scRNA-seq analysis preprocessing. 

```{r}
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj)
obj <- ScaleData(obj)
obj <- RunPCA(obj)
obj
```

## Determine the 'dimensionality' of the dataset

To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a 'metafeature' that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many components should we choose to include? 10? 20? 100?

An alternative heuristic method generates an 'Elbow plot': a ranking of principle components based on the percentage of variance explained by each one (`ElbowPlot()` function). In this example, we can observe an 'elbow' around PC14-15, suggesting that the majority of true signal is captured in the first 15 PCs. 

```{r elbow_plot, fig.height=6, fig.width=10}
ElbowPlot(obj)
```

The `FindClusters()` contains a resolution parameter that sets the 'granularity' of the downstream clustering, *with increased values leading to a greater number of clusters*. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the `Idents()` function.

```{r cluster}
obj <- FindNeighbors(obj, dims = 1:15)
obj <- FindClusters(obj, resolution = 0.1)
```

```{r umap}
obj <- RunUMAP(obj, dims = 1:15)
obj@meta.data
```

```{r fig.height=12, fig.width=15}
DimPlot(obj, reduction = "umap", group.by = c("orig.ident", "seurat_clusters","ind","tissue"), alpha=0.4, ncol=2)
```

Here we will set the identity to the clusters, and view the frequency of the resulting cell identities:

```{r}
table(obj$RNA_snn_res.0.1)
```

```{r}
Idents(obj) = "tissue"
table(Idents(obj))
```

```{r}
ca_n_de = FindMarkers(obj, ident.1="Ca",ident.2="N",test.use="wilcox")
head(ca_n_de, 10)
```

```{r}
fig1 = DimPlot(obj,group.by="tissue")
fig2 = FeaturePlot(obj,features="CXCL8",order=T)
fig3 = FeaturePlot(obj,features="PLEK",order=T)

fig1/(fig2|fig3)
```

```{r}
pseudo_obj=AggregateExpression(obj,assays="RNA", return.seurat=T, group.by=c("orig.ident","ind","tissue"))

head(pseudo_obj@assays$RNA$counts)
```

```{r}
pseudo_obj@meta.data
```
```{r}
Idents(pseudo_obj)="tissue"
bulk_obj_de = FindMarkers(pseudo_obj, ident.1="Ca", ident.2="N", test.use="DESeq2")

```

```{r}
head(bulk_obj_de)
```
```{r}
scDE.genes = rownames(ca_n_de)[which(ca_n_de$p_val_adj<0.05)]
bulkDE.genes = rownames(bulk_obj_de)[which(bulk_obj_de$p_val_adj<0.05)]
length(scDE.genes)
length(bulkDE.genes)
length(intersect(scDE.genes,bulkDE.genes))

```
```{r}
Idents(obj) = "tissue"
VlnPlot(obj,features=c("CXCL8","CFD"),alpha = 0.1)
```

## Cell annotation
We will now use a package called SingleR to label each cell. SingleR uses a reference data set of cell types with expression data to infer the best label for each cell. A convenient collection of cell type reference is in the `celldex` package which currently contains the follow sets:

```{r}
ls('package:celldex')
```
In this example, we’ll use the `HumanPrimaryCellAtlasData` set, which contains high-level, and fine-grained label types. Lets download the reference dataset.

```{r}
ref.set <- celldex::HumanPrimaryCellAtlasData()
```

We’ll convert our Seurat object into an object called SingleCellExperiment.
```{r}
obj <- JoinLayers(obj)
sce <- as.SingleCellExperiment(obj)
sce
```
Now we’ll label our cells using the SingleCellExperiment object, with the above reference set.

```{r}
pred.cnts <- SingleR::SingleR(test = sce, ref = ref.set, labels = ref.set$label.main)
obj$singleR.labels <- pred.cnts$labels
obj@meta.data
```

The object contains data from six different batches (stored in the `orig.ident` column in the object metadata), representing six different data files. We will aim to integrate the different batches together. We can instead keep all the data in one object, but simply split the layers.

```{r splitassay}
obj[["RNA"]] <- split(obj[["RNA"]], f = obj$orig.ident)
obj
```
## Perform integrative analysis

When data is collected from multiple samples, multiple runs of the single cell sequencing library preparation, or multiple conditions, cells of the same type may become separated in the UMAP and be put into several different clusters.

For the purpose of clustering and cell identification, we would like to remove such effects.

There is a big difference between tumor and peritumor tissue cells. This has split cells of the same type into pairs of clusters.

We will use Harmony, which can remove non-uniform effects. We will try to remove both the small differences between individuals and the large difference between the tumor and non-tumor cells.

Harmony operates only on the PCA scores. The original gene expression levels remain unaltered.

```{r integratelayersharmony, results='hide'}
obj <- IntegrateLayers(
  object = obj, method = HarmonyIntegration,
  orig.reduction = "pca", new.reduction = 'harmony',
  verbose = T)
obj
```

This has added a new set of reduced dimensions to the Seurat object, `kang$harmony` which is a modified version of the existing `kang$pca` reduced dimensions. The PCA plot shows some difference between '`Ca`' and '`N`', but this has been removed in the harmony reduction.
```{r comparepca}
DimPlot(obj, reduction="pca", group.by="tissue")
DimPlot(obj, reduction="harmony", group.by="tissue")
```

For any of the methods, we can now visualize and cluster the datasets.

```{r integratedprojections, fig.height=16, fig.width=16}
obj <- FindNeighbors(obj, reduction = 'harmony', dims = 1:30)
obj <- FindClusters(obj, resolution = 2, cluster.name = 'harmony_clusters')
obj <- RunUMAP(obj, reduction = "harmony", dims = 1:30, reduction.name = 'umap.harmony')
p1 <- DimPlot(
  obj, reduction = "umap.harmony",
  group.by = c("ind", "tissue", "singleR.labels", "harmony_clusters"),
  combine = FALSE, label.size = 2) 
p1
```
## Differential composition analysis
We utilize our harmonized annotations to identify differences in the proportion of different cell types between healthy individuals and COVID-19 patients. For example, we noticed a reduction in MAIT cells as well as an increase in plasmablasts among COVID-19 patients.

```{r}
df_comp <- as.data.frame.matrix(table(object$donor_id, object$predicted.celltype.l2))
select.donors <- rownames(df_comp)[rowSums(df_comp)> 50]
df_comp <- df_comp[select.donors, ]
df_comp_relative <- sweep(x = df_comp, MARGIN = 1, STATS = rowSums(df_comp), FUN = '/')

df_disease <-  as.data.frame.matrix(table(object$donor_id, object$disease))[select.donors, ]

df_comp_relative$disease <- 'other'
df_comp_relative$disease[df_disease$normal!=0] <- 'normal'
df_comp_relative$disease[df_disease$`COVID-19`!=0] <- 'COVID-19'
df_comp_relative$disease <- factor(df_comp_relative$disease, levels = c('normal','COVID-19','other'))
df_comp_relative <- df_comp_relative[df_comp_relative$disease %in% c('normal','COVID-19'),]
```

```{r, fig.width=10, fig.height=4}
p1 <-  ggplot(data = df_comp_relative, mapping = aes(x = disease, y = MAIT, fill = disease)) +  
  geom_boxplot(outlier.shape  = NA) +
  scale_fill_manual(values = c("#377eb8", "#e41a1c")) +
  xlab("") + ylab('relative abundance') +
  ggtitle('MAIT') +
  geom_jitter(color="black", size=0.4, alpha=0.9 ) +
  theme_bw() +
  theme( axis.title = element_text(size = 12),
         axis.text = element_text(size = 12),
         plot.title = element_text(size = 15, hjust = 0.5, face = "bold")
  )

p2 <-  ggplot(data = df_comp_relative, mapping = aes(x = disease, y = Plasmablast, fill = disease)) +  
  geom_boxplot(outlier.shape  = NA) +
  scale_fill_manual(values = c("#377eb8", "#e41a1c")) +
  xlab("") + ylab('relative abundance') +
    ggtitle('Plasmablast') +
  geom_jitter(color="black", size=0.4, alpha=0.9 ) +
  theme_bw() +
  theme( axis.title = element_text(size = 12),
         axis.text = element_text(size = 12),
         plot.title = element_text(size = 15, hjust = 0.5, face = "bold")
  )

p1 + p2 + plot_layout(ncol = 2)
```

## Identify differential expressed genes across conditions
How many cells per individuals per group?
```{r}
table(obj$ind, obj$tissue)
```

```{r}
obj
obj <- JoinLayers(obj)
```
We can now ask what genes change in different conditions for cells of the same type. First, we create a column in the meta.data slot to hold both the cell type and stimulation information and switch the current ident to that column. Then we use `FindMarkers()` to find the genes that are different between tumor and non-tumor epithelial cells.  

Please note that p-values obtained from this analysis should be interpreted with caution, as these tests treat each cell as an independent replicate, and ignore inherent correlations between cells originating from the same sample. As discussed [here](https://pubmed.ncbi.nlm.nih.gov/33257685/), DE tests across multiple conditions should expressly utilize multiple samples/replicates, and can be performed after aggregating ('pseudobulking') cells from the same sample and subpopulation together. We do not perform this analysis here, as there is a single replicate in the data, but please see our [vignette comparing healthy and diabetic samples](https://satijalab.org/seurat/articles/parsebio_sketch_integration) as an example for how to perform DE analysis across conditions.

```{r}
obj$celltype.tissue <- paste(obj$singleR.labels, obj$tissue, sep = "_")
Idents(obj) <- "celltype.tissue"
epi.response <- FindMarkers(obj, ident.1 = "Epithelial_cells_Ca", ident.2 = "Epithelial_cells_N", verbose = FALSE)
head(epi.response, n = 15)
```

```{r feature.heatmaps, fig.height = 10, fig.width=10}
FeaturePlot(obj, features = c("STMN1", "CDKN2A", "KRT5"), split.by = "tissue", max.cutoff = 3, cols = c("grey",
    "red"), reduction = "umap.harmony")
```
```{r splitvln, fig.height = 12}
plots <- VlnPlot(obj, features = c("LYZ", "ISG15", "CXCL10"), split.by = "tissue", group.by = "singleR.labels", pt.size = 0, combine = FALSE)
wrap_plots(plots = plots, ncol = 1)
```

We hope that by simplifying the process of performing integrative analysis, users can more carefully evaluate the biological information retained in the integrated dataset. For example, users can compare the expression of biological markers based on different clustering solutions, or visualize one method's clustering solution on different UMAP visualizations.

```{r vlnplots, fig.height=5, fig.width=16, warning=FALSE}
p1 <- VlnPlot(
  obj, features = "rna_CD8A", group.by = 'unintegrated_clusters'
) + NoLegend() + ggtitle("CD8A - Unintegrated Clusters")
p2 <- VlnPlot(
  obj, "rna_CD8A", group.by = 'cca_clusters'
) + NoLegend() + ggtitle("CD8A - CCA Clusters")
p3 <- VlnPlot(
  obj, "rna_CD8A", group.by = 'scvi_clusters'
) + NoLegend() + ggtitle("CD8A - scVI Clusters")
p1 | p2 | p3
```

```{r umaps, fig.height=5, fig.width=16}
obj <- RunUMAP(obj, reduction = "integrated.rpca", dims = 1:30, reduction.name = 'umap.rpca')
p4 <- DimPlot(obj, reduction="umap.unintegrated", group.by=c("cca_clusters"))
p5 <- DimPlot(obj, reduction="umap.rpca", group.by=c("cca_clusters"))
p6 <- DimPlot(obj, reduction="umap.scvi", group.by=c("cca_clusters"))
p4 | p5 | p6
```

Once integrative analysis is complete, you can rejoin the layers - which collapses the individual datasets together and recreates the original `counts` and `data` layers. You will need to do this before performing any differential expression analysis. However, you can always resplit the layers in case you would like to reperform integrative analysis.

```{r joinlayers}
obj <- JoinLayers(obj)
obj
```

Lastly, users can also perform integration using sctransform-normalized data (see our [SCTransform vignette](https://satijalab.org/seurat/articles/sctransform_vignette) for more information), by first running SCTransform normalization, and then setting the `normalization.method` argument in `IntegrateLayers`.

```{r, include=FALSE}
obj <- LoadData("pbmcsca")
obj <- subset(obj, nFeature_RNA > 1000)
obj[["RNA"]] <- split(obj[["RNA"]], f = obj$Method)
```

```{r sct}
options(future.globals.maxSize = 3e+09)
obj <- SCTransform(obj)
obj <- RunPCA(obj, npcs = 30, verbose = F)
obj <- IntegrateLayers(object = obj, 
                           method = RPCAIntegration,
                           normalization.method="SCT",
                           verbose = F)
obj <- FindNeighbors(obj, dims = 1:30,reduction = 'integrated.dr')
obj <- FindClusters(obj, resolution = 2)
obj <- RunUMAP(obj, dims = 1:30,reduction = 'integrated.dr')
```

<details>
  <summary>**Session Info**</summary>
```{r}
sessionInfo()
```
</details>
